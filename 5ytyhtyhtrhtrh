-- FULLY AUTOMATIC ROBLOX HOPPER - MOBILE SUPPORT (PASTEBIN MODE)
-- This script uses Pastebin instead of local files for Android/mobile executors
-- Reads job IDs from Pastebin raw URL updated by scannermobile.js

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

-- ===== CONFIGURATION =====
local CONFIG = {
    -- Pastebin Configuration (replace with your actual Pastebin raw URL)
    PASTEBIN_RAW_URL = getgenv().PASTEBIN_RAW_URL or "https://gist.githubusercontent.com/pjglizzyoyogz-bot/bb2baf7e03d5a50cb282e8931384317d/raw/b7b3b9563a846f913f8de24b6cfa8c7c86e5aa9d/jobids.json",
    
    -- Game Configuration
    UNIVERSE_ID = 109983668079237, -- place/universe id used for teleport
    PLACE_ID = 109983668079237,    -- explicit place id
    
    -- Timing
    CHECK_INTERVAL = 0.25,
    RETRY_DELAY = 0.5,
    MAX_RETRY_ATTEMPTS = 3,
    FAST_MODE = true,
    CACHE_TTL = 2, -- seconds to cache HTTP responses
    MAX_LOOP_BURST = 15,
    
    -- Client ID
    CLIENT_ID = HttpService:GenerateGUID(false)
}

-- ===== HTTP REQUEST HELPER =====
local request = (function()
    local methods = {
        syn and syn.request,
        http and http.request,
        http_request,
        fluxus and fluxus.request,
        request
    }
    for _, method in ipairs(methods) do
        if method then return method end
    end
    error("No HTTP request function found!")
end)()

-- ===== SHARED GLOBAL STATE =====
_G.ServerHopperShared = _G.ServerHopperShared or {
    assignedJobIds = {},
    localBlocklist = {}
}

-- ===== STATE =====
local State = {
    currentJobId = nil,
    isAttemptingJoin = false,
    retryCount = 0,
    assignedJobIds = {},
    lastBlocklistCheck = 0
}

-- ===== LOGGING =====
local function log(message, level)
    if CONFIG.FAST_MODE and level ~= "ERROR" and level ~= "WARN" then return end
    level = level or "INFO"
    local timestamp = os.date("%H:%M:%S")
    print(string.format("[%s][%s] %s", timestamp, level, message))
end

local function logError(message) log(message, "ERROR") end
local function logWarning(message) log(message, "WARN") end

-- ===== PASTEBIN STORAGE (replaces file I/O) =====
local _cache = { data = nil, ts = 0 }

local function httpGetJobStore()
    local url = CONFIG.PASTEBIN_RAW_URL
    local ok, response = pcall(function()
        return request({
            Url = url,
            Method = "GET",
            Headers = { ["Accept"] = "application/json" }
        })
    end)
    
    if not ok or not response or response.StatusCode ~= 200 then
        logError("Failed to fetch job store from Pastebin")
        return nil
    end
    
    local parseOk, data = pcall(function()
        return HttpService:JSONDecode(response.Body)
    end)
    
    if not parseOk then
        logError("Failed to parse job store response")
        return nil
    end
    
    return data
end

local function httpBlockJobId(jobId, reason)
    -- Pastebin is read-only for clients, just track locally
    table.insert(_G.ServerHopperShared.localBlocklist, jobId)
    log("üö´ Locally blocked JobId: " .. jobId .. " (" .. (reason or "unknown") .. ")")
    return true
end

local function httpSkipJobId(jobId)
    -- Pastebin is read-only, skip functionality is client-side only
    if not CONFIG.FAST_MODE then log("‚è≠Ô∏è Skipping JobId: " .. jobId) end
end

local function storageRead(force)
    local now = os.clock()
    if not force and _cache.data and (now - _cache.ts) < CONFIG.CACHE_TTL then
        return _cache.data
    end
    
    local result = httpGetJobStore()
    
    if result then
        _cache.data = result
        _cache.ts = now
        return result
    end
    
    -- Fallback to cached data
    if _cache.data then
        if not CONFIG.FAST_MODE then log("Using cached data due to fetch failure") end
        return _cache.data
    end
    
    return nil
end

-- ===== JOB ID MANAGEMENT =====
local function getNextJobId()
    local data = storageRead()
    if not data then return nil end
    
    local available = data.availableJobIds or {}
    local blocklist = data.blocklist or {}
    
    if #available == 0 then return nil end
    
    -- Build fast lookup sets
    local blockedSet = {}
    for _, b in ipairs(blocklist) do blockedSet[b] = true end
    
    local triedSet = {}
    for _, t in ipairs(State.assignedJobIds) do triedSet[t] = true end
    
    local globalAssigned = _G.ServerHopperShared.assignedJobIds
    
    -- Reservoir-style random pick
    local pick = nil
    local count = 0
    
    for _, jobId in ipairs(available) do
        if not blockedSet[jobId] and not triedSet[jobId] and 
           (not globalAssigned[jobId] or globalAssigned[jobId] == CONFIG.CLIENT_ID) then
            count = count + 1
            if math.random(count) == 1 then pick = jobId end
        end
    end
    
    if not pick then
        logWarning("No valid JobId (all blocked/used)")
        return nil
    end
    
    table.insert(State.assignedJobIds, pick)
    globalAssigned[pick] = CONFIG.CLIENT_ID
    
    if not CONFIG.FAST_MODE then log("Selected JobId: " .. pick) end
    return pick
end

local function blockJobId(jobId, reason)
    log("üö´ Blocking JobId: " .. jobId .. " | Reason: " .. reason)
    table.insert(_G.ServerHopperShared.localBlocklist, jobId)
    httpBlockJobId(jobId, reason)
end

local function preBlockJobId(jobId)
    -- Pre-block immediately to prevent race conditions
    httpBlockJobId(jobId, "pre_block_before_teleport")
    _G.ServerHopperShared.localBlocklist[jobId] = true
    return true
end

-- ===== TELEPORT LOGIC =====
local function parseErrorReason(errorMsg)
    local errorLower = tostring(errorMsg):lower()
    
    if string.find(errorLower, "full") or string.find(errorLower, "capacity") then
        return "Server is full"
    elseif string.find(errorLower, "can't join private") or string.find(errorLower, "cant join private") or 
           string.find(errorLower, "unauthorized") then
        return "Private / Unauthorized instance"
    elseif string.find(errorLower, "invalid") or string.find(errorLower, "not found") then
        return "Invalid or closed server"
    elseif string.find(errorLower, "restricted") or string.find(errorLower, "private") then
        return "Server is private or restricted"
    else
        return "Unknown error: " .. tostring(errorMsg)
    end
end

local function attemptTeleport(jobId)
    if State.isAttemptingJoin then return false end
    if not jobId or jobId == "" then
        logError("AttemptTeleport called with nil/empty jobId")
        return false
    end
    
    State.isAttemptingJoin = true
    if not CONFIG.FAST_MODE then log("Attempt teleport -> " .. tostring(jobId)) end
    
    local player = Players.LocalPlayer
    local success, errorMessage = pcall(function()
        TeleportService:TeleportToPlaceInstance(CONFIG.PLACE_ID or CONFIG.UNIVERSE_ID, jobId, player)
    end)
    
    if not success then
        local reason = parseErrorReason(errorMessage)
        logError("Teleport failed: " .. reason .. " | jobId=" .. tostring(jobId))
        
        -- Check if server is full (skip) vs unavailable (block)
        if string.find(reason:lower(), "full") then
            httpSkipJobId(jobId)
        else
            blockJobId(jobId, reason)
        end
        
        State.isAttemptingJoin = false
        State.currentJobId = nil
        State.retryCount = State.retryCount + 1
        return false
    end
    
    if not CONFIG.FAST_MODE then log("Teleport initiated jobId=" .. tostring(jobId)) end
    return true
end

-- ===== MAIN LOOP =====
local function mainLoop()
    log("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    log("‚ïë    üéÆ AUTOMATIC SERVER HOPPER - MOBILE SUPPORT (PASTEBIN) ‚ïë")
    log("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    log("Client ID: " .. CONFIG.CLIENT_ID)
    log("Universe ID: " .. CONFIG.UNIVERSE_ID)
    log("Pastebin URL: " .. CONFIG.PASTEBIN_RAW_URL)
    log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    -- Resilient store loading
    local attempt = 0
    local testData
    repeat
        attempt = attempt + 1
        if attempt == 1 then
            log("üîç Loading job store from Pastebin...")
        else
            logWarning("Retrying fetch (attempt " .. attempt .. ")")
        end
        testData = storageRead(true)
        if not testData then
            local backoff = math.min(10, 1 * 2 ^ math.min(6, attempt - 1))
            logWarning("Pastebin unreachable. Backing off for " .. backoff .. "s")
            wait(backoff)
        end
    until testData ~= nil
    
    log("‚úÖ Store ready after " .. attempt .. " attempt(s)")
    log("üìä Found " .. #(testData.availableJobIds or {}) .. " available JobIds")
    log("")
    
    local burst = 0
    while true do
        -- Already in target server
        if game.JobId ~= "" and game.JobId == State.currentJobId then
            wait(5)
        else
            if State.retryCount >= CONFIG.MAX_RETRY_ATTEMPTS then
                if State.currentJobId then 
                    blockJobId(State.currentJobId, "Max retries exceeded") 
                end
                State.currentJobId = nil
                State.retryCount = 0
                wait(CONFIG.RETRY_DELAY)
            end
            
            if not State.currentJobId then
                State.currentJobId = getNextJobId()
                if not State.currentJobId then
                    wait(CONFIG.RETRY_DELAY)
                end
            end
            
            if State.currentJobId then
                local jid = State.currentJobId
                if jid and jid ~= "" then
                    preBlockJobId(jid)
                    attemptTeleport(jid)
                else
                    State.currentJobId = nil
                end
            end
        end
        
        burst = burst + 1
        if burst >= CONFIG.MAX_LOOP_BURST then
            burst = 0
            wait(CONFIG.CHECK_INTERVAL)
        else
            task.wait()
        end
    end
end

-- ===== EVENT HANDLERS =====
Players.LocalPlayer.OnTeleport:Connect(function(state)
    if state == Enum.TeleportState.Started then
        log("üîÑ Teleport started...")
    elseif state == Enum.TeleportState.InProgress then
        log("üîÑ Teleport in progress...")
    elseif state == Enum.TeleportState.Failed then
        logError("‚ùå Teleport failed!")
        if State.currentJobId then
            blockJobId(State.currentJobId, "Teleport failed (OnTeleport event)")
            State.currentJobId = nil
        end
        State.isAttemptingJoin = false
    end
end)

-- ===== STARTUP =====
log("Initializing mobile hopper (Pastebin mode)...")
wait(0.1)

-- Start the main loop
spawn(function()
    local success, error = pcall(mainLoop)
    if not success then
        logError("üíÄ Fatal error: " .. tostring(error))
    end
end)

log("‚úÖ Server hopper is running (Mobile Support - Pastebin)!")
