-- FULLY AUTOMATIC ROBLOX HOPPER - LOCAL FILE MODE
-- This script reads from a local JSON file populated by the scanner
-- No HTTP requests needed - pure local file mode

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

-- ===== CONFIGURATION =====
local CONFIG = {
    -- Local File Configuration
    LOCAL_FILE_PATH = "C:/Users/ghait/AppData/Roaming/Zenith/Workspace/JobidJson.json", -- Windows absolute path
    
    -- Game Configuration
    UNIVERSE_ID = 109983668079237, -- place/universe id used for teleport (ensure this is PlaceId, not universe id if different)
    PLACE_ID = 109983668079237,    -- explicit place id (change if different from universe)
    
    -- Timing
    CHECK_INTERVAL = 0.25, -- base polling interval (reduced)
    RETRY_DELAY = 0.5,     -- delay after failure (short)
    MAX_RETRY_ATTEMPTS = 3,
    FAST_MODE = true,      -- enable aggressive speed optimizations
    JSON_CACHE_TTL = 2,    -- seconds to cache file read
    MAX_LOOP_BURST = 15,   -- max rapid iterations before yielding
    
    -- Client ID (unique per account)
    CLIENT_ID = HttpService:GenerateGUID(false)
}

-- ===== SHARED GLOBAL STATE (across all accounts) =====
_G.ServerHopperShared = _G.ServerHopperShared or {
    assignedJobIds = {}, -- JobIds currently assigned to any account
    localBlocklist = {} -- Local blocklist cached from file
}

-- ===== STATE =====
local State = {
    currentJobId = nil,
    isAttemptingJoin = false,
    retryCount = 0,
    assignedJobIds = {}, -- Track what this client has been assigned
    lastBlocklistCheck = 0 -- Last time we checked blocklist
}

-- ===== LOGGING =====
local function log(message, level)
    if CONFIG.FAST_MODE and level ~= "ERROR" and level ~= "WARN" then return end
    level = level or "INFO"
    local timestamp = os.date("%H:%M:%S")
    print(string.format("[%s][%s] %s", timestamp, level, message))
end

local function logError(message) log(message, "ERROR") end
local function logWarning(message) log(message, "WARN") end

-- ===== STORAGE (Local File) =====
local _cache = { data = nil, ts = 0 }

local function readLocalFile()
    if not isfile or not readfile then
        logError("Executor does not expose file APIs (isfile/readfile)")
        return nil
    end

    -- helper to trim and check emptiness
    local function isEmptyString(s)
        return s == nil or s == "" or not tostring(s):find("%S")
    end

    -- ensure file exists; if not, create a minimal valid structure
    if not isfile(CONFIG.LOCAL_FILE_PATH) then
        logWarning("Local file missing: " .. CONFIG.LOCAL_FILE_PATH .. " -> creating base file")
        if writefile then
            local seed = { availableJobIds = {}, blocklist = {}, stats = { created = os.time(), reason = "created_missing" } }
            local okCreate, errCreate = pcall(function()
                writefile(CONFIG.LOCAL_FILE_PATH, HttpService:JSONEncode(seed))
            end)
            if not okCreate then
                logError("Failed to create base file: " .. tostring(errCreate))
                return nil
            end
        else
            return nil
        end
    end

    -- read with a few retries to survive concurrent partial writes
    local lastErr
    for attempt = 1, 5 do
        local okRead, content = pcall(readfile, CONFIG.LOCAL_FILE_PATH)
        if not okRead then
            lastErr = content
            logWarning("Read attempt " .. attempt .. " failed: " .. tostring(content))
            wait(0.2)
        else
            if isEmptyString(content) then
                -- empty/whitespace-only -> recreate a base file
                logWarning("Local file is empty -> recreating base JSON")
                if writefile then
                    local seed = { availableJobIds = {}, blocklist = {}, stats = { recreated = os.time(), reason = "empty" } }
                    pcall(function() writefile(CONFIG.LOCAL_FILE_PATH, HttpService:JSONEncode(seed)) end)
                    return seed
                else
                    return nil
                end
            end
            local okDecode, decoded = pcall(function()
                return HttpService:JSONDecode(content)
            end)
            if okDecode and type(decoded) == "table" then
                return decoded
            else
                lastErr = decoded
                -- likely read during a write (partial JSON); brief retry
                if attempt < 5 then wait(0.25) end
            end
        end
    end

    -- If we get here, decoding kept failing. Try to recover by rewriting a sane base.
    logWarning("Invalid JSON in local file after retries -> attempting recovery")
    local seedFromCache = { availableJobIds = {}, blocklist = {}, stats = { recovered = os.time(), reason = "corrupt_after_retries" } }
    if _cache and _cache.data then
        seedFromCache.availableJobIds = _cache.data.availableJobIds or {}
        seedFromCache.blocklist = _cache.data.blocklist or {}
        if type(_cache.data.stats) == "table" then
            for k, v in pairs(_cache.data.stats) do seedFromCache.stats[k] = v end
        end
        seedFromCache.stats.recoveredFromCache = true
    end
    if writefile then
        local okWrite = pcall(function()
            writefile(CONFIG.LOCAL_FILE_PATH, HttpService:JSONEncode(seedFromCache))
        end)
        if okWrite then
            return seedFromCache
        end
    end
    logError("Invalid JSON in local file (unrecoverable)")
    return nil
end

local function writeLocalFile(tbl)
    if not writefile then return false end
    local ok, err = pcall(function()
        writefile(CONFIG.LOCAL_FILE_PATH, HttpService:JSONEncode(tbl))
    end)
    if not ok then
        logWarning("Failed writing local file: " .. tostring(err))
        return false
    end
    return true
end

local function storageRead(force)
    local now = os.clock()
    if not force and _cache.data and (now - _cache.ts) < CONFIG.JSON_CACHE_TTL then
        return _cache.data
    end
    
    local result = readLocalFile()
    
    if result then
        _cache.data = result
        _cache.ts = now
        return result
    end
    -- Fallback to cached data to avoid stalls when reads temporarily fail
    if _cache.data then
        if not CONFIG.FAST_MODE then log("Using cached data due to read failure") end
        return _cache.data
    end
    return nil
end

local function storageWrite(data)
    return writeLocalFile(data)
end

-- ===== JOB ID MANAGEMENT =====
local function getNextJobId()
    local data = storageRead()
    if not data then return nil end
    local available = data.availableJobIds or {}
    local blocklist = data.blocklist or {}
    if #available == 0 then return nil end
    -- build fast lookup sets once per call
    local blockedSet = {}
    for _, b in ipairs(blocklist) do blockedSet[b] = true end
    local triedSet = {}
    for _, t in ipairs(State.assignedJobIds) do triedSet[t] = true end
    local globalAssigned = _G.ServerHopperShared.assignedJobIds
    -- reservoir style random pick without building big tables
    local pick = nil
    local count = 0
    for _, jobId in ipairs(available) do
        if not blockedSet[jobId] and not triedSet[jobId] and (not globalAssigned[jobId] or globalAssigned[jobId] == CONFIG.CLIENT_ID) then
            count = count + 1
            if math.random(count) == 1 then pick = jobId end
        end
    end
    if not pick then
        logWarning("No valid JobId (all blocked/used)")
        return nil
    end
    table.insert(State.assignedJobIds, pick)
    globalAssigned[pick] = CONFIG.CLIENT_ID
    if not CONFIG.FAST_MODE then log("Selected JobId: " .. pick) end
    return pick
end

local function blockJobId(jobId, reason)
    log("🚫 Blocking JobId: " .. jobId .. " | Reason: " .. reason)
    
    -- Add to local blocklist immediately
    table.insert(_G.ServerHopperShared.localBlocklist, jobId)
    
    local data = storageRead()
    if not data then
        -- Create a minimal structure so we can still persist the block
        data = { availableJobIds = {}, blocklist = {} }
    end
    
    -- Add to blocklist if not already there
    local blocklist = data.blocklist or {}
    local alreadyBlocked = false
    
    for _, blockedId in ipairs(blocklist) do
        if blockedId == jobId then
            alreadyBlocked = true
            break
        end
    end
    
    if not alreadyBlocked then
        table.insert(blocklist, jobId)
        data.blocklist = blocklist
        
        -- REMOVE from availableJobIds list
        local newAvailable = {}
        for _, id in ipairs(data.availableJobIds or {}) do
            if id ~= jobId then
                table.insert(newAvailable, id)
            end
        end
        data.availableJobIds = newAvailable
        
    if storageWrite(data) then
            log("✅ JobId blocked and removed from available list")
            return true
        end
    else
        log("ℹ️  JobId already blocked")
    end
    
    return false
end

-- Pre-block job id (lightweight: edits JsonBin once) so no other account selects it while we are teleporting
local function preBlockJobId(jobId)
    -- read cached (force refresh)
    local data = storageRead(true)
    if not data then
        data = { availableJobIds = {}, blocklist = {} }
    end
    data.blocklist = data.blocklist or {}
    -- already blocked? then fine
    for _, b in ipairs(data.blocklist) do if b == jobId then return true end end
    table.insert(data.blocklist, jobId)
    -- remove from available list immediately
    if data.availableJobIds then
        local filtered = {}
        for _, id in ipairs(data.availableJobIds) do if id ~= jobId then table.insert(filtered, id) end end
        data.availableJobIds = filtered
    end
    if storageWrite(data) then
        -- also reflect in cache structures
        _G.ServerHopperShared.localBlocklist[jobId] = true
        return true
    end
    return false
end

-- ===== TELEPORT LOGIC =====
local function parseErrorReason(errorMsg)
    local errorLower = tostring(errorMsg):lower()
    
    if string.find(errorLower, "full") or string.find(errorLower, "capacity") then
        return "Server is full"
    elseif string.find(errorLower, "can't join private") or string.find(errorLower, "cant join private") or string.find(errorLower, "unauthorized") then
        return "Private / Unauthorized instance"
    elseif string.find(errorLower, "invalid") or string.find(errorLower, "not found") then
        return "Invalid or closed server"
    elseif string.find(errorLower, "restricted") or string.find(errorLower, "private") then
        return "Server is private or restricted"
    else
        return "Unknown error: " .. tostring(errorMsg)
    end
end

local function attemptTeleport(jobId)
    if State.isAttemptingJoin then return false end
    if not jobId or jobId == "" then
        logError("AttemptTeleport called with nil/empty jobId")
        return false
    end
    State.isAttemptingJoin = true
    if not CONFIG.FAST_MODE then log("Attempt teleport -> " .. tostring(jobId)) end
    local player = Players.LocalPlayer
    local success, errorMessage = pcall(function()
        TeleportService:TeleportToPlaceInstance(CONFIG.PLACE_ID or CONFIG.UNIVERSE_ID, jobId, player)
    end)
    if not success then
        local reason = parseErrorReason(errorMessage)
        logError("Teleport failed: " .. reason .. " | jobId=" .. tostring(jobId))
        blockJobId(jobId, reason)
        State.isAttemptingJoin = false
        State.currentJobId = nil
        State.retryCount = State.retryCount + 1
        return false
    end
    if not CONFIG.FAST_MODE then log("Teleport initiated jobId=" .. tostring(jobId)) end
    return true
end

-- ===== MAIN LOOP =====
local function mainLoop()
    log("╔════════════════════════════════════════════════════════════╗")
    log("║     🎮 FULLY AUTOMATIC SERVER HOPPER - LOCAL FILE MODE    ║")
    log("╚════════════════════════════════════════════════════════════╝")
    log("Client ID: " .. CONFIG.CLIENT_ID)
    log("Universe ID: " .. CONFIG.UNIVERSE_ID)
    log("Local File: " .. CONFIG.LOCAL_FILE_PATH)
    log("════════════════════════════════════════════════════════════")
    
    -- Removed auto-block of current server; we only block the NEXT one we select (pre-block before teleport)
    
    -- Resilient file loading (keep retrying)
    local attempt = 0
    local testData
    repeat
        attempt += 1
        if attempt == 1 then
            log("🔍 Loading local file...")
        else
            logWarning("Retrying file read (attempt " .. attempt .. ")")
        end
        testData = storageRead(true)
        if not testData then
            local backoff = math.min(10, 1 * 2 ^ math.min(6, attempt - 1)) -- 1,2,4,8,10,10...
            logWarning("File unreadable. Backing off for " .. backoff .. "s")
            wait(backoff)
        end
    until testData ~= nil
    log("✅ File ready after " .. attempt .. " attempt(s)")
    log("📊 Found " .. #(testData.availableJobIds or {}) .. " available JobIds")
    log("")
    
    local burst = 0
    while true do
        -- Already in server we targeted
        if game.JobId ~= "" and game.JobId == State.currentJobId then
            -- slow down while settled
            wait(5)
        else
            if State.retryCount >= CONFIG.MAX_RETRY_ATTEMPTS then
                if State.currentJobId then blockJobId(State.currentJobId, "Max retries exceeded") end
                State.currentJobId = nil
                State.retryCount = 0
                wait(CONFIG.RETRY_DELAY)
            end
            if not State.currentJobId then
                State.currentJobId = getNextJobId()
                if not State.currentJobId then
                    wait(CONFIG.RETRY_DELAY)
                end
            end
            if State.currentJobId then
                -- Pre-block it so others can't pick it concurrently
                local jid = State.currentJobId
                if jid and jid ~= "" then
                    preBlockJobId(jid)
                    local ok = attemptTeleport(jid)
                    if not ok then
                        -- release attempt? (already blocklisted to avoid thrash)
                    end
                else
                    State.currentJobId = nil
                end
                if not ok then
                    -- immediate new try next loop
                end
            end
        end
        burst = burst + 1
        if burst >= CONFIG.MAX_LOOP_BURST then
            burst = 0
            wait(CONFIG.CHECK_INTERVAL)
        else
            task.wait() -- yield briefly
        end
    end
end

-- ===== EVENT HANDLERS =====
Players.LocalPlayer.OnTeleport:Connect(function(state)
    if state == Enum.TeleportState.Started then
        log("🔄 Teleport started...")
    elseif state == Enum.TeleportState.InProgress then
        log("🔄 Teleport in progress...")
    elseif state == Enum.TeleportState.Failed then
        logError("❌ Teleport failed!")
        if State.currentJobId then
            blockJobId(State.currentJobId, "Teleport failed (OnTeleport event)")
            State.currentJobId = nil
        end
        State.isAttemptingJoin = false
    end
end)

-- ===== STARTUP =====
log("Initializing local file hopper...")
wait(0.1)

-- Start the main loop
spawn(function()
    local success, error = pcall(mainLoop)
    if not success then
        logError("💀 Fatal error: " .. tostring(error))
    end
end)

log("✅ Server hopper is running!")
